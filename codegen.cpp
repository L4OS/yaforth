
// codegen.cpp : This is gode generatore for Etherest assemler
// 
// With hope that this is useful stuff but without any warrany
//
// This file distributed under Xameleon Green License
//
//
#include "generators.h"
#include "yaforth.h"
#include <chrono>

#ifdef _WIN32
 #define itoa _itoa
#else

char * itoa(uint32_t v, char * buff, int r)
{
    int n = snprintf(buff, 16, "%d", v);
    if(!n) {
    n = snprintf(buff, 16, "0");
    }
    return buff;
}

#endif

static FILE* OUT = stdout;
static unsigned int label_idx = 0;
static unsigned int loop_count = 0;
bool  show_pcode = true;

static std::map<word_t, std::string>    iflabels;

void append_label(const char *s, word_t addr)
{
    iflabels[addr] = s;
}

void genetate_strings(ram_memory& memory)
{
    function_list_t program = get_program();
    for (const auto& fun : program)
    {
        for (const auto& str : fun.strings)
        {
            auto name = str.first.c_str();
            auto value = str.second;

            function_t* cf = lookup_current_function();
            if (cf)
            {
                uint32_t    storage = memory.get_current_address();

//                for (const auto& i : cf->strings)
                {
                    fprintf(OUT, "%s\tdb\t'", name);
                    uint32_t idx = value;
                    memory.jump(idx);
                    uint32_t len = memory.get();

                    int rest = len % 4;
                    for (int l = (len + 3) / 4; l; --l)
                    {
                        bool lw = len == 1;
                        word_t w = memory.get();
                        for (int j = 0; j < (lw ? rest : 4); ++j)
                        {
                            int mask = 0xff & w;
                            w >>= 8;
                            if (!mask)
                                fprintf(OUT, "\0");
                            else
                                fprintf(OUT, "%c", mask);
                        }
                    }
                    fprintf(OUT, "\', 0\n");
//                    memory.jump(storage);
                }
            }
        }
    }
    fprintf(OUT, "\n");
}

void generate_code(const char * src, ram_memory & memory, registry_t & words)
{
    word_t     word, prev;

    memory.jump(0);

#if _WIN32
    const std::chrono::time_point now{ std::chrono::system_clock::now() };
    const std::chrono::year_month_day ymd{ std::chrono::floor<std::chrono::days>(now) };
#else
    const auto  now = std::chrono::system_clock::now();
    const std::time_t t_c = std::chrono::system_clock::to_time_t(now);
#endif

    if(src)
    {
        std::string  filename(src);
        filename.append(".asm");

        OUT = fopen(filename.c_str(), "wt");
        if (!OUT) {
            OUT = stderr;
            fprintf(OUT, "Unable open file '%s' for writing\n", filename.c_str());
        }

    }
    else
    {
        OUT = stdout;
    }
    
#ifdef _WIN32
    fprintf(OUT, ";  --- This is autogenerated on %04d%02d%02d from %s ---\n\n", 
        ymd.year(), ymd.month(),ymd.day(), src);
#else
    std::string tns = std::ctime(&t_c);
    fprintf(OUT, ";  --- This is autogenerated on %s;  --- from %s ----\n\n", 
        tns.c_str(), src);
#endif

    fprintf(OUT, "assign    r14    esp		; Return stack pointer\n");
    fprintf(OUT, "assign    r11    stack		; Data stack\n\n");

    fprintf(OUT, "$fourth    equ    3		    ; Fourth element\n\n");
    fprintf(OUT, "$third     equ    2		    ; Third element\n\n");
    fprintf(OUT, "$second    equ    1		    ; Second element\n\n");

    fprintf(OUT, "function crt0\n");
    fprintf(OUT, "    load	stack, 0x8000; Set Data stack\n");
    fprintf(OUT, "    load	esp,   0x7000; Set Return stack\n");
    fprintf(OUT, "    call	_main\n");
    fprintf(OUT, "    send\n");
    fprintf(OUT, "end\n\n");
    fprintf(OUT, "  include    lib/asm/tty/tty.asm\n");
    fprintf(OUT, "  include    lib/asm/tty/print_dec.asm\n");
    fprintf(OUT, "  include    lib/asm/emulate/mul.asm\n\n");

    word = prev = 0;
    word_t prepre = 0;
    bool vars_marked = false;

    for (int i = 0; memory.get_current_address() < memory.get_execution_address(); ++i )
    {
        word_t a = memory.get_current_address();
        if (iflabels.count(a)) {
            fprintf(OUT, "%s:\n", iflabels[a].c_str());
        }

        prepre = prev;
        prev = word;
        word = memory.get();

        if (words.count(word) == 0) {
            const char* note = find_variable_by_address(a);
            if (note == nullptr)
                note = "Not in dictionary";
                
            fprintf(OUT, "    dq    0x%08x ; %s IP = %08x\n", word, note, a);
            vars_marked = true;
            continue;
        }

        if (vars_marked) {
            fprintf(OUT, "\n");
            vars_marked = false;
        }

        record_t* rec = &words[word];
        switch (rec->TYPE)
        {
        case builtin:
            if (rec->NAME.size() == 0)
            {
                ;
            }
            if(show_pcode)
                fprintf(OUT, "; --- WORD [%d] = %s\n", i, rec->NAME.c_str());
            if (rec->GENERATE)
                rec->GENERATE(&memory, rec);
            break;
        case user:
            if (show_pcode)
                fprintf(OUT, "; --- WORD [%d]\n", i);
            fprintf(OUT, "    call    %s\n", rec->NAME.c_str());
            break;
        case constant:
            if (show_pcode)
                fprintf(OUT, "WORD [%d] = %d\n", i, rec->CONSTANT);
            break;

        default:
            fprintf(OUT, "Unparsed type\n");
        }
    }
    genetate_strings(memory);
}

void asm_push_value(ram_memory * mem, struct word_record* rec)
{
    word_t  value = mem->get();
    fprintf(OUT, "    load    r6, %d\n", value);
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r6\n");
}

void asm_jump(ram_memory* mem, struct word_record* rec)
{
    word_t a = mem->get();

    char buff[100];
    std::string label("label_");
    label += itoa(a, buff, 10);

    fprintf(OUT, "    jmp    %s\n", label.c_str());
    append_label(label.c_str(), a);
}

void asm_here(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), stack\n");
}

void asm_store(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, ";;  ---------  ASM store -----------\n");
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r5, (stack)\n");
    fprintf(OUT, "    shl    r6, 2\n");
//    fprintf(OUT, "    mov    r5, (r6)\n");
//    fprintf(OUT, "    mov    (stack), r5\n");
    fprintf(OUT, "    mov    (r6), r5\n");
}

void asm_fetch(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    shl    r6, 2\n");
    fprintf(OUT, "    mov    r5, (r6)\n");
    fprintf(OUT, "    mov    (stack), r5\n");
}

void asm_add(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r5, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    clc\n");
    fprintf(OUT, "    addc   r6, r5\n");
    fprintf(OUT, "    mov    (stack), r6\n");
}

void asm_sub(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r5, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    clc\n");
    fprintf(OUT, "    subc   r6, r5\n");
    fprintf(OUT, "    mov    (stack), r6\n");
}

void asm_mul(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r0, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r1, (stack)\n");
    fprintf(OUT, "    call   _mul\n");
    fprintf(OUT, "    mov    (stack), r2\n");
}

void asm_div(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r2, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r0, (stack)\n");
    fprintf(OUT, "    call   _div\n");
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_check_equ(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    xor    r0, r0\n");
    fprintf(OUT, "    cmp    r6, (stack)\n");
    fprintf(OUT, "    jnz    notsame_%d\n", ++label_idx);
    fprintf(OUT, "    load   r0, -1\n");
    fprintf(OUT, "notsame_%d:\n", label_idx);
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_check_notequ(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    xor    r0, r0\n");
    fprintf(OUT, "    cmp    r6, (stack)\n");
    fprintf(OUT, "    jz     same_%d\n", ++label_idx);
    fprintf(OUT, "    load   r0, -1\n");
    fprintf(OUT, "same_%d:\n", label_idx);
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_check_less(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    xor    r0, r0\n");
    fprintf(OUT, "    cmp    r6, (stack)\n");
    fprintf(OUT, "    jbe    noless_%d\n", ++label_idx);
    //fprintf(OUT, "    jc    noless_%d\n", ++label_idx);
    ////    fprintf(OUT, "    jnc    noless_%d\n", ++label_idx);
    fprintf(OUT, "    load   r0, -1\n");
    fprintf(OUT, "noless_%d:\n", label_idx);
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_check_more(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    xor    r0, r0\n");
    fprintf(OUT, "    cmp    r6, (stack)\n");
    fprintf(OUT, "    ja     nomore_%d\n", ++label_idx);
    //fprintf(OUT, "    jnc     nomore_%d\n", ++label_idx);
    ////    fprintf(OUT, "    jc     nomore_%d\n", ++label_idx);
    fprintf(OUT, "    load   r0, -1\n");
    fprintf(OUT, "nomore_%d:\n", label_idx);
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_and(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    and    (stack), r6\n");
}

void asm_or(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    or     (stack), r6\n");
}

void asm_xor(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    xor     (stack), r6\n");
}

void asm_left_shift(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r5, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    shl    r6, r5\n");
    fprintf(OUT, "    mov    (stack), r6\n");
}

void asm_right_shift(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r5, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    shr    r6, r5\n");
    fprintf(OUT, "    mov    (stack), r6\n");
}

void asm_not(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    not    (stack)\n");
}

void asm_mod(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r2, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r0, (stack)\n");
    fprintf(OUT, "    call   _div\n");
    fprintf(OUT, "    mov    (stack), r2\n");
}

void asm_divmod(ram_memory* mem, struct word_record* rec)
{
//    fprintf(OUT, "    xor    r1, r1\n");
    fprintf(OUT, "    mov    r2, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r0, (stack)\n");
    fprintf(OUT, "    call   _div\n");
    fprintf(OUT, "    mov    (stack), r2\n");
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_dup(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r6\n");
}

void asm_swap(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, stack[4]\n");
    fprintf(OUT, "    mov    r5, (stack)\n");
    fprintf(OUT, "    mov    (stack), r6\n");
    fprintf(OUT, "    mov    stack[4], r5\n");
}

void asm_over(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, stack[4]\n");
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r6\n");
}

void asm_rot(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    mov    r5, stack[4]\n");
    fprintf(OUT, "    mov    r4, stack[8]\n");
    fprintf(OUT, "    mov    (stack), r6\n");    // Лениво думать, легче отладить в эиуляторе
    fprintf(OUT, "    mov    stack[4], r4\n");
    fprintf(OUT, "    mov    stack[8], r5\n");
}

void asm_drop(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    inc    stack, 4\n");
}

void asm_dot(ram_memory* mem, struct word_record* rec)
{
     fprintf(OUT, "    mov    r0, (stack)\n");

     fprintf(OUT, "    load   r3, 0x80000000\n");
     fprintf(OUT, "    and   r3, r0\n");
     fprintf(OUT, "    je    label_print_%d\n", ++label_idx);

     fprintf(OUT, "    neg    r0\n");
     fprintf(OUT, "    mov    (stack), r0\n");
     fprintf(OUT, "    load   r3, 45 ; '-'\n");
     fprintf(OUT, "    call   _putchar\n");
     fprintf(OUT, "    mov    r0, (stack)\n");

     fprintf(OUT, "label_print_%d:\n", label_idx);
     fprintf(OUT, "    call   _print_dec\n");
     fprintf(OUT, "    load   r3, 32\n");
     fprintf(OUT, "    call   _putchar\n");
     fprintf(OUT, "    inc    stack, 4\n");
}

void asm_key(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    call   _getchar\n");
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_emit(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r3, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    call   _putchar\n");
}

void asm_print_string(ram_memory* mem, struct word_record* rec)
{
    static int draw_string_counter = 0;
   
    std::string  text("$textline_");
    ++draw_string_counter;
    text += std::to_string(draw_string_counter);

    word_t jmp = mem->get();
    word_t addr = mem->get();
    bool  local = try_register_local_string(text, mem->get_current_address());
    word_t len = mem->get();
    if (local)
    {
        if (len & 0x3)
            len = 1 + (len % 4) + mem->get_current_address();
        else
            len = (len % 4) + mem->get_current_address();
        mem->jump(addr);
    }
    else
    {
        //        fprintf(OUT, "    jmp    puts_%d ; \n\n", ++label_idx);
        fprintf(OUT, "%s\tdb\t'", text.c_str());
        int rest = len % 4;
        for (int l = (len + 3) / 4; l; --l)
        {
            bool lw = len == 1;
            word_t w = mem->get();
            for (int j = 0; j < (lw ? rest : 4); ++j)
            {
                int mask = 0xff & w;
                w >>= 8;
                if (!mask)
                    fprintf(OUT, "\0");
                else
                    fprintf(OUT, "%c", mask);
            }
        }
        fprintf(OUT, "\' ; To fix\n\n");
        //    fprintf(OUT, "puts_%d:\n", label_idx);
    }

    fprintf(OUT, "    lea   r1, %s\n", text.c_str());
    fprintf(OUT, "    call   _puts\n");
}

void asm_return(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov   r15, (esp)\n");
    fprintf(OUT, "    inc   esp, 4\n");
    fprintf(OUT, "    return\n");
    fprintf(OUT, "end\n\n");
}

void asm_if(ram_memory* mem, struct word_record* rec)
{
    word_t w = mem->get();

    char buff[100];
    std::string label("nottrue_");
    label += itoa(w, buff, 10);
    fprintf(OUT, "    mov    r0, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    or    r0, r0\n");
    fprintf(OUT, "    jz    %s\n", label.c_str());
    append_label(label.c_str(), w);
}

void asm_to_R(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r0, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    dec    esp, 4\n");
    fprintf(OUT, "    mov    (esp), r0\n");
}

void asm_from_R(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r0, (esp)\n");
    fprintf(OUT, "    inc    esp, 4\n");
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_fetch_R(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r0, (esp)\n");
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_function(ram_memory* mem, struct word_record* rec)
{
    word_t w = mem->get();
    struct word_record* fn = find_record(w);
    if (!fn) {
        fprintf(stderr, "Cannot find function\n");
        return;
    }
    fprintf(OUT, "function %s\n", fn->NAME.c_str());
    fprintf(OUT, "    dec   esp, 4\n");
    fprintf(OUT, "    mov   (esp), r15\n");
}

void asm_loop(ram_memory* mem, struct word_record* rec)
{
    ++loop_count;
    fprintf(OUT, "    mov    r0, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r1, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    dec    esp, 8\n");
//    fprintf(OUT, "    mov    esp[4], r1\n");        // Или наоборт? В отладку!
    fprintf(OUT, "    mov    esp.second, r1\n");
    fprintf(OUT, "    mov    (esp), r0\n");
    fprintf(OUT, "looplabel_%d:\n", loop_count); // Добаить стек меток
}

void asm_endloop(ram_memory* mem, struct word_record* rec)
{
    word_t  addr = mem->get();
    fprintf(OUT, "    mov    r0, (esp)\n");
    fprintf(OUT, "    inc    r0\n");
    fprintf(OUT, "    mov    (esp), r0\n");
    fprintf(OUT, "    cmp    r0, esp.second\n");
    fprintf(OUT, "    jne    looplabel_%d\n", loop_count);
    fprintf(OUT, "leave_%d:\n", loop_count--);
    fprintf(OUT, "    inc    esp, 8\n");
}
void asm_endplusloop(ram_memory* mem, struct word_record* rec)
{
    word_t  addr = mem->get();
    fprintf(OUT, "    mov    r6, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    mov    r0, (esp)\n");
    fprintf(OUT, "    clc\n");
    fprintf(OUT, "    addc   r0, r6\n");
    fprintf(OUT, "    mov    (esp), r0\n");
    fprintf(OUT, "    cmp    r0, esp.second\n");
    fprintf(OUT, "    jne    looplabel_%d\n", loop_count);
    fprintf(OUT, "leave_%d:\n", loop_count--);
    fprintf(OUT, "    inc    esp, 8\n");
}
void asm_index_i(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r0, (esp)\n");
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_index_j(ram_memory* mem, struct word_record* rec)
{
    if (loop_count < 2)
    {
        fprintf(stderr, "No j variable defined in current context\n");
        exit(-1);
    }
    fprintf(OUT, ";;; debug\n");
    fprintf(OUT, "    mov    r0, esp.third\n");
    fprintf(OUT, "    dec    stack, 4\n");
    fprintf(OUT, "    mov    (stack), r0\n");
}

void asm_leave(ram_memory* mem, struct word_record* rec)
{
//    fprintf(OUT, "    inc    esp, 8\n");
    word_t  addr = mem->get();
    fprintf(OUT, "    jmp    leave_%d\n", loop_count);

}

void asm_beginloop(ram_memory* mem, struct word_record* rec)
{
    loop_count++;
    fprintf(OUT, "loopbegin_%d:\n", loop_count); // Добаить стек меток
}

void asm_untilloop(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    mov    r0, (stack)\n");
    fprintf(OUT, "    inc    stack, 4\n");
    fprintf(OUT, "    inc    r0\n");
    fprintf(OUT, "    js     loopbegin_%d\n", loop_count);

    loop_count--;
}

void asm_again(ram_memory* mem, struct word_record* rec)
{
    fprintf(OUT, "    jmp     loopbegin_%d\n", loop_count);
    fprintf(OUT, "leave_%d:\n", loop_count);
    loop_count--;
}
